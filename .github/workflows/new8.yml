name: Build HeborisCE (RockNIX-style Linux ARM64)

on:
  workflow_dispatch:
  push:
    branches: ["main"]

jobs:
  build:
    name: Build HeborisCE (aarch64)
    runs-on: ubuntu-latest
    container:
      image: ubuntu:25.04

    steps:
      - name: Install tools + cross toolchain (RockNIX-style)
        run: |
          set -euxo pipefail
          apt-get update
          apt-get install -y git curl ca-certificates xz-utils

          dpkg --add-architecture arm64

          # Pin DEB822 sources to amd64 only (avoid broken arm64 indexes on security.ubuntu.com)
          for f in /etc/apt/sources.list.d/*.sources; do
            if [ -f "$f" ] && ! grep -q '^Architectures:' "$f"; then
              sed -i '/^Types:/a Architectures: amd64' "$f"
            fi
          done

          # Add arm64 sources via ports.ubuntu.com (this is the trick that made your 3SX workflow work)
          printf '%s\n' \
            'deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports plucky main restricted universe multiverse' \
            'deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports plucky-updates main restricted universe multiverse' \
            'deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports plucky-security main restricted universe multiverse' \
            > /etc/apt/sources.list.d/arm64-ports.list

          apt-get update
          apt-get install -y \
            crossbuild-essential-arm64 \
            cmake ninja-build pkg-config \
            zip tar file

          # SDL3 + SDL3_image headers/libs (ARM64)
          apt-get install -y \
            libsdl3-dev:arm64 \
            libsdl3-image-dev:arm64

          # Extra runtime codec deps (ARM64) so we can bundle real SONAME files (no symlinks)
          apt-get install -y \
            liblerc4:arm64 \
            libjbig0:arm64 \
            libdeflate0:arm64 \
            libmd0:arm64


      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: Create toolchain file (aarch64-linux-gnu)
        run: |
          set -euxo pipefail
          mkdir -p cmake
          cat > cmake/aarch64-linux-gnu.cmake << 'EOF'
          set(CMAKE_SYSTEM_NAME Linux)
          set(CMAKE_SYSTEM_PROCESSOR aarch64)

          set(CMAKE_C_COMPILER aarch64-linux-gnu-gcc)
          set(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)
          set(CMAKE_AR aarch64-linux-gnu-ar)
          set(CMAKE_RANLIB aarch64-linux-gnu-ranlib)
          set(CMAKE_STRIP aarch64-linux-gnu-strip)

          # Multiarch locations for :arm64 packages on Ubuntu
          set(CMAKE_LIBRARY_ARCHITECTURE aarch64-linux-gnu)
          set(CMAKE_FIND_ROOT_PATH
              /usr
              /usr/include/aarch64-linux-gnu
              /usr/lib/aarch64-linux-gnu
          )

          set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
          set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
          set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
          set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
          EOF

      - name: Configure (Portable package type)
        run: |
          set -euxo pipefail

          # Make pkg-config resolve ARM64 .pc files
          export PKG_CONFIG_LIBDIR=/usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig
          export PKG_CONFIG_PATH=$PKG_CONFIG_LIBDIR
          export PKG_CONFIG_SYSROOT_DIR=/

          cmake -S . -B build-linux-arm64 -G Ninja \
            -DCMAKE_TOOLCHAIN_FILE=cmake/aarch64-linux-gnu.cmake \
            -DCMAKE_BUILD_TYPE=Release \
            -DAPP_PACKAGE_TYPE=Portable

      - name: Build
        run: |
          set -euxo pipefail
          cmake --build build-linux-arm64 --parallel
          echo "=== built files ==="
          find build-linux-arm64 -maxdepth 3 -type f -print

      - name: Package (PortMaster-friendly folder)
        run: |
          set -euxo pipefail
          mkdir -p dist/heborisce/libs

          # Find the built binary (common locations across generators)
          BIN="$(find build-linux-arm64 -maxdepth 4 -type f -executable -name 'HeborisCE*' | head -n 1)"
          if [ -z "${BIN:-}" ]; then
            echo "ERROR: Could not find HeborisCE executable in build-linux-arm64"
            find build-linux-arm64 -maxdepth 4 -type f -print
            exit 1
          fi
          echo "Using BIN=$BIN"
          cp -v "$BIN" dist/heborisce/HeborisCE

          # Copy resources (most important is res/)
          if [ -d "res" ]; then
            cp -av res dist/heborisce/
          fi

          # Copy common docs (optional, harmless)
          for f in changelog.txt heboris.txt README* LICENSE*; do
            [ -e "$f" ] && cp -av "$f" dist/heborisce/ || true
          done

          # Bundle SDL3 + SDL3_image WITHOUT symlinks (RockNIX /storage often can't create symlinks)
          # Copy the real versioned files and rename to the SONAME the loader wants (.so.0)
          SDL3_REAL="$(ls -1 /usr/lib/aarch64-linux-gnu/libSDL3.so.0.* 2>/dev/null | head -n 1 || true)"
          SDL3IMG_REAL="$(ls -1 /usr/lib/aarch64-linux-gnu/libSDL3_image.so.0.* 2>/dev/null | head -n 1 || true)"

          [ -n "$SDL3_REAL" ] && cp -aLv "$SDL3_REAL" dist/heborisce/libs/libSDL3.so.0 || true
          [ -n "$SDL3IMG_REAL" ] && cp -aLv "$SDL3IMG_REAL" dist/heborisce/libs/libSDL3_image.so.0 || true

          echo "=== SDL3 libs bundled ==="
          ls -la dist/heborisce/libs || true

          # Bundle a few common SDL3_image/audio backend deps as real SONAME files (no symlinks)
          WEBP_REAL="$(ls -1 /usr/lib/aarch64-linux-gnu/libwebp.so.7.* 2>/dev/null | head -n 1 || true)"
          WEBPDEMUX_REAL="$(ls -1 /usr/lib/aarch64-linux-gnu/libwebpdemux.so.2.* 2>/dev/null | head -n 1 || true)"
          SNDIO_REAL="$(ls -1 /usr/lib/aarch64-linux-gnu/libsndio.so.7.* 2>/dev/null | head -n 1 || true)"
          [ -n "$WEBP_REAL" ] && cp -aLv "$WEBP_REAL" dist/heborisce/libs/libwebp.so.7 || true
          [ -n "$WEBPDEMUX_REAL" ] && cp -aLv "$WEBPDEMUX_REAL" dist/heborisce/libs/libwebpdemux.so.2 || true
          [ -n "$SNDIO_REAL" ] && cp -aLv "$SNDIO_REAL" dist/heborisce/libs/libsndio.so.7 || true

          # Bundle deps found missing via ldd sweep on RockNIX (ship as real SONAME files; no symlinks)
          # NOTE: some packages may only provide the SONAME file (e.g. libLerc.so.4) without a .4.x.y suffix.
          pick_so() { ls -1 /usr/lib/aarch64-linux-gnu/$1* /lib/aarch64-linux-gnu/$1* 2>/dev/null | head -n 1 || true; }

          echo "=== probing for extra deps in container ==="
          for n in libLerc.so.4 libjbig.so.0 libdeflate.so.0 libmd.so.0; do
            echo "$n -> $(pick_so $n || true)"
            ls -l /usr/lib/aarch64-linux-gnu/$n* /lib/aarch64-linux-gnu/$n* 2>/dev/null || true
          done

          LERC_CAND="$(pick_so libLerc.so.4)"
          JBIG_CAND="$(pick_so libjbig.so.0)"
          DEFLATE_CAND="$(pick_so libdeflate.so.0)"
          MD_CAND="$(pick_so libmd.so.0)"

          [ -n "$LERC_CAND" ] && cp -aLv "$LERC_CAND" dist/heborisce/libs/libLerc.so.4 || true
          [ -n "$JBIG_CAND" ] && cp -aLv "$JBIG_CAND" dist/heborisce/libs/libjbig.so.0 || true
          [ -n "$DEFLATE_CAND" ] && cp -aLv "$DEFLATE_CAND" dist/heborisce/libs/libdeflate.so.0 || true
          [ -n "$MD_CAND" ] && cp -aLv "$MD_CAND" dist/heborisce/libs/libmd.so.0 || true

          # Fail early if key deps we expect to ship are still missing from package step
          for need in libLerc.so.4 libjbig.so.0 libdeflate.so.0 libmd.so.0; do
            if [ ! -f "dist/heborisce/libs/$need" ]; then
              echo "ERROR: expected to bundle $need but it is missing. Check apt packages / paths."
              dpkg -l | grep -E 'liblerc|libjbig|libdeflate|libmd' || true
              dpkg -L liblerc4:arm64 2>/dev/null || true
              dpkg -L libjbig0:arm64 2>/dev/null || true
              dpkg -L libdeflate0:arm64 2>/dev/null || true
              dpkg -L libmd0:arm64 2>/dev/null || true
              exit 1
            fi
          done


          # Bundle remaining deps found missing via ldd sweep on RockNIX
          LERC_REAL="$(ls -1 /usr/lib/aarch64-linux-gnu/libLerc.so.4.* 2>/dev/null | head -n 1 || true)"
          JBIG_REAL="$(ls -1 /usr/lib/aarch64-linux-gnu/libjbig.so.0.* 2>/dev/null | head -n 1 || true)"
          DEFLATE_REAL="$(ls -1 /usr/lib/aarch64-linux-gnu/libdeflate.so.0.* 2>/dev/null | head -n 1 || true)"
          SHARPYUV_REAL="$(ls -1 /usr/lib/aarch64-linux-gnu/libsharpyuv.so.0.* 2>/dev/null | head -n 1 || true)"
          BSD_REAL="$(ls -1 /usr/lib/aarch64-linux-gnu/libbsd.so.0.* 2>/dev/null | head -n 1 || true)"

          [ -n "$LERC_REAL" ] && cp -aLv "$LERC_REAL" dist/heborisce/libs/libLerc.so.4 || true
          [ -n "$JBIG_REAL" ] && cp -aLv "$JBIG_REAL" dist/heborisce/libs/libjbig.so.0 || true
          [ -n "$DEFLATE_REAL" ] && cp -aLv "$DEFLATE_REAL" dist/heborisce/libs/libdeflate.so.0 || true
          [ -n "$SHARPYUV_REAL" ] && cp -aLv "$SHARPYUV_REAL" dist/heborisce/libs/libsharpyuv.so.0 || true
          [ -n "$BSD_REAL" ] && cp -aLv "$BSD_REAL" dist/heborisce/libs/libbsd.so.0 || true

          # Optional: copy SDL3_image direct dependencies (keeps port self-contained if RockNIX is missing them)
          # We avoid copying core glibc/loader libs.
          if [ -n "$SDL3IMG_REAL" ]; then
            echo "=== SDL3_image NEEDED deps ==="
            aarch64-linux-gnu-readelf -d "$SDL3IMG_REAL" | grep NEEDED || true

            for so in $(aarch64-linux-gnu-readelf -d "$SDL3IMG_REAL" | awk '/NEEDED/{gsub(/\[|\]/, "", $5); print $5}'); do
              case "$so" in
                ld-linux-aarch64.so.1|libc.so.6|libm.so.6|libdl.so.2|librt.so.1|libpthread.so.0|libgcc_s.so.1|libstdc++.so.6) continue ;;
                libz.so.1|libbz2.so.1.0|liblzma.so.5|libsndio.so.7|libmd.so.0|libLerc.so.4|libjbig.so.0|libdeflate.so.0) continue ;;
              esac
              CAND="$(ls -1 /usr/lib/aarch64-linux-gnu/$so /usr/lib/aarch64-linux-gnu/${so}.* 2>/dev/null | head -n 1 || true)"
              if [ -n "$CAND" ]; then
                # If it's a versioned file, copy it as-is (loader will find it by exact filename in NEEDED)
                cp -aLv "$CAND" dist/heborisce/libs/ || true
              fi
            done
          fi

          # Simple run script
          cat > dist/heborisce/run.sh << 'EOF'
          #!/bin/sh
          set -eu
          DIR="$(cd "$(dirname "$0")" && pwd)"
          cd "$DIR"
          export LD_LIBRARY_PATH="$DIR/libs:${LD_LIBRARY_PATH:-}"
          exec "$DIR/HeborisCE"
          EOF
          chmod +x dist/heborisce/run.sh

          echo "=== package contents ==="
          find dist -maxdepth 4 -type f -print

          (cd dist && tar -czf ../heborisce-linux-arm64.tar.gz heborisce)

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: heborisce-linux-arm64
          path: heborisce-linux-arm64.tar.gz
          if-no-files-found: error
